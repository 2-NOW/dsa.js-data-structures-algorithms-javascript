[appendix]
[[d-interview-questions-solutions]]
== Interview Questions Solutions
(((Interview Questions Solutions)))

=== Solutions for Array Questions
(((Interview Questions Solutions, Arrays)))

==== Max Subarray [[array-q-max-subarray]]
include::content/part02/array.asc[tag=array-q-max-subarray]

The first step, is making sure we understand the problem well. Let's do a basic examples:

----
A = [-5, 6, 9, -8]
B = [-1, 6, -3, 8]
----

What's the subarrays with the maximum sum? For A, it will be `[6, 9]` and for B it will be `[6, -3, 8]`.

One intution could be to generate all possible subarrays, add them up and then pick the max number.

[source, javascript]
----
include::interview-questions/max-subarray.js[tag=maxSubArrayBrute1]
----

This is a simple to understand however not very efficient. The runtime is `O(n^3)`.

If you noticed we adding up the numbers from `i` to `j` on each cycle. But, we can optimize this. We can keep a local variable and add the new number to it. That way we don't have to revisit previous numebers again.

[source, javascript]
----
include::interview-questions/max-subarray.js[tag=maxSubArrayBrute2]
----

The runtime is much better: `O(n)`. Can we still do better?

We can use a greedy approach, where do one pass through the array. We only add the numbers if their sum is larger than just taking the current element.

[source, javascript]
----
include::interview-questions/max-subarray.js[tag=description]
include::interview-questions/max-subarray.js[tag=solution]
----

The runtime is `O(n)`! and a space complexity of `O(1)`.
