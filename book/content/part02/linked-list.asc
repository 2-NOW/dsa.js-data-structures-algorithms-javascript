ifndef::imagesdir[]
:imagesdir: ../../images
:codedir: ../../../src
endif::[]

(((Linked List)))
(((List)))
(((Data Structures, Linear, Linked List)))
[[linked-list]]
=== Linked List

A list (or Linked List) is a linear data structure where each object has a pointer to the next one.

.Linked Lists can be:
- *Singly*: every item has a pointer to the next.
- *Doubly*: every item has a reference to the next and the previous.
- *Circular*: the last element points to the first one, forming an infinite loop.

JavaScript doesn't have a built-in List. However, it's straightforward to create.

[[node-class]]
.Linked List Node Implementation
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/node.js[tag=snippet]
----

Let's go one by one!

[[singly-linked-list]]
==== Singly Linked List

In a singly linked list, each element or node is *connected* to the next one by a reference.

Usually, a Linked List is referenced by the first element called *head* (or *root* node). Let's say that we have a list of strings with the following values: `"art" -> "dog" -> "cat"`. It would look something like the following image.

.Singly Linked List Representation: each node has a reference (blue arrow) to the next one.
image::image19.png[image,width=498,height=97]

If you want to get the `cat` element from the example above, then the only way to get there is by using the `next` field on the head node. You would get `art` first, then use the next field recursively until you eventually get the `cat` element.

[[doubly-linked-list]]
==== Doubly Linked List

Doubly Linked List has two references to the `next` and `previous` node.

.Doubly Linked List: each node has a reference to the next and previous element.
image::dll.png[]

With a doubly-linked list, you can move not only forward but also backward. If you keep a pointer to the `last` element (`cat`), you can step back recursively.

Finding an item on the linked list takes O(n) time. Because in the worst-case, you will have to iterate over the whole list.

==== Linked List vs. Array

Arrays give you instant access to data anywhere in the collection using an index. However, Linked List visits nodes in sequential order. In the worst-case scenario, it takes _O(n)_ to get an element from a Linked List. You might be wondering: Isn’t an array always more efficient with _O(1)_ access time? It depends.

We also have to understand the space complexity to see the trade-offs between arrays and linked lists. An array pre-allocates contiguous blocks of memory. If the array fillup, it has to create a larger array (usually 2x) and copy all the elements when it is getting full.  That takes _O(n)_ to copy all the items over. On the other hand, LinkedList’s nodes only reserve precisely the amount of memory they need. They don’t have to be next to each other in RAM, nor are large chunks of memory is booked beforehand like arrays. Linked List is more on a "grow as you go" basis. *Linked list wins on memory usage over an array.*

Another difference is that adding/deleting at the beginning of an array takes `O(n)`; however, the linked list is a constant operation `O(1)` as we will implement later. *Linked List has better runtime than an array for inserting items at the beginning.*

==== Implementing a Linked List

We are going to implement a doubly linked list. First, let's start with the constructor.

The only must-have field on the constructor is the `first` or head reference.  If you want to insert it to the back of the list in constant time, then `last` pointer is needed. Everything else is complimentary.

.Linked List's constructor
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/linked-list.js[tag=constructor]

  // ... methods go here ...
}
----

The iterable parameter is a nice to have. That will allow you to convert an array of items into a linked list. E.g. `const list = new LinkedList([1, 2, 3]);`

==== Searching by value or index

There’s no other way to find an element by value than iterating through the list. So, the runtime is `O(n)`.

There are two prominent use cases for search: find an element by value, or find them by their index/position.

We can use a for-loop to keep track of the index and the current node simultaneously. Whichever fulfill first, we return that one.

[[linkedlist.findBy]]
.Linked List's searching by values or index
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/linked-list.js[tag=find, indent=0]
----
<1> We initialize two variables `current` to the first node and `position` to 0 to keep track of the ordinal number.
<2> While the `current` node is not null, we keep going.
<3> On each loop, we move to the next node and increment the index.
<4> We check if the index is the one provided or if the node has the expected value.
<5> Returns the index and the current node if found.

==== Insertion

You can add elements at the beginning, end, or anywhere in the middle of the list in a linked list. So, let's implement each case.

[[linked-list-inserting-beginning]]
===== Inserting elements at the beginning of the list

We will use the <<node-class, Node class>> to create a new element and stick it at the beginning of the list, as shown below.

.Insert at the beginning by linking the new node with the current first node.
image::dll-add-first.png[]


To insert at the beginning, we create a new node with the next reference to the current first node. Then we update the pointer `first` to the new node. In code, it would look something like this:

.Add item to the beginning of a Linked List
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/linked-list.js[tag=addFirst, indent=0]
----
<1> It might be confusing seen `this.first.previous`. It means that we are updating the `previous` pointer of the `art` node to point to `new`.


===== Inserting element at the end of the list

Appending an element at the end of the list can be done very effectively if we have a pointer to the `last` item. Otherwise, you would have to iterate through the whole list.

.Add element to the end of the linked list
image::dll-add-last.png[]

.Linked List's add to the end of the list implementation
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/linked-list.js[tag=addLast, indent=0]
----

If there’s no element in the list yet, the first and last node would be the same. If there’s something, we go to the `last` item and add the reference `next` to the new node. That’s it! We got a constant time for inserting at the beginning and the end of the list: *O(1)*.


===== Inserting element at the middle of the list

For inserting an element in the middle of the list, you would need to specify the position (index) in the list. Then, you create the new node and update the references around it.

.There are four references to update:
. New node's `next`.
. New node's `previous`.
. New node's previous `next`.
. New node's next `previous`.


Let’s do an example with the following doubly linked list:

----
art <-> dog <-> cat
----

We want to insert the `new` node in the 2^nd^ position (index 1). For that, we first create the "new" node and update the references around it.

[[dll-insert-middle-img]]
.Inserting node in the middle.
image::dll-insert-middle.png[]

Take a look into the implementation of `LinkedList.add`:

.Linked List's add to the middle of the list
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/linked-list.js[tag=addMiddle, indent=0]
----
<1> If the new item goes to position 0, then we reuse the `addFirst` method, and we are done!
<2> However, if we add to the last position, we reuse the `addLast` method and done!
<3> Adding `newNode` to the middle: First, create the `new` node only if it exists. Take a look at <<linkedlist.findBy>> to see `findBy` implementation again.
<4> Set newNode `previous` reference.
<5> Set newNode `next` link.
<6> So far, no other node in the list points to `newNode`, so we the `art` node's next point to `new` (refer to the <<dll-insert-middle-img, illustration>>).
<7> Make `dog` node's previous point to `new`.

Take notice that we reused `addFirst` and `addLast` methods. For all the other cases, the insertion is in the middle. We use `current.previous.next` and `current.next` to update the surrounding elements and point to the new node. Inserting in the middle takes *O(n)* because we have to iterate through the list using the `findBy` method.

==== Deletion

Deleting is an interesting one. We don’t delete an element; we remove all references to that node. The garbage collector will remove it when no one points to it. Let’s go case by case to explore what happens.

===== Deleting element from the head

Deleting the first element (or head) is a matter of removing all references to it.

.Deleting an element from the head of the list
image::dll-remove-first.png[]

For instance, to remove the head (“art”) node, we change the variable `first` to point to the second node, “dog”. We also remove the variable `previous` from the "dog" node, so it doesn't reference the “art” node anymore. The garbage collector will get rid of the “art” node when it sees nothing is using it anymore.

.Linked List's remove from the beginning of the list
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/linked-list.js[tag=removeFirst, indent=0]
----
.Check for edge cases:
- List is already empty.
- Removing the last node.

As you can see, when we want to remove the first node, we make the 2nd element (`head.next`) the first one.

===== Deleting element from the tail

Removing the last element from the list would require iterate from the head until we find the last one, that’s `O(n)`. But, since we referenced the last element, we can do it in _O(1)_ instead!

.Removing the last element from the list.
image::dll-remove-last.png[]


For instance, if we want to remove the last node “cat”. We use the last pointer to avoid iterating through the whole list. We check `last.previous` to get the “dog” node and make it the new `last` and remove its next reference to “cat.” Since nothing is pointing to “cat” it is out of the list and eventually is deleted from memory by the garbage collector.

.Linked List's remove from the end of the list
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/linked-list.js[tag=removeLast, indent=0]
----


The code is very similar to `removeFirst`, but instead of first, we update `last` reference, and instead of nullifying `previous`, we nullify its `next` reference.

===== Deleting element from the middle

To remove a node from the middle, we make the surrounding nodes bypass the one we want to delete.

.Remove the middle node
image::dll-remove-middle.png[]

In the illustration, we are removing the middle node “dog” by making art’s `next` variable to point to cat and cat’s `previous` to be “art,” totally bypassing “dog.”

Let’s implement it:

.Linked List's remove from the middle of the list
[source, javascript]
----
include::{codedir}/data-structures/linked-lists/linked-list.js[tag=removeByPosition, indent=0]
----

Notice that we are using the `get` method to get the node at the current position. That method loops through the list until it found the node at the specified location. This iteration has a runtime of _O(n)_.

(((Tables, Linear DS, Array/Lists complexities)))

==== Linked List Complexity vs. Array Complexity

// tag::table[]
.Big O cheat sheet for Linked List and Array
|===
.2+.^s| Data Structure 2+^s| Searching By 3+^s| Inserting at the 3+^s| Deleting from .2+.^s| Space
^|_Index/Key_ ^|_Value_ ^|_beginning_ ^|_middle_ ^|_end_ ^|_beginning_ ^|_middle_ ^|_end_
| Array ^|O(1) ^|O(n) ^|O(n) ^|O(n) ^|O(1) ^|O(n) ^|O(n) ^|O(1) ^|O(n)
| Linked List (singly) ^|O(n) ^|O(n) ^|O(1) ^|O(n) ^|O(n) ^|O(1) ^|O(n) ^|*O(n)* ^|O(n)
| Linked List (doubly) ^|O(n) ^|O(n) ^|O(1) ^|O(n) ^|O(1) ^|O(1) ^|O(n) ^|*O(1)* ^|O(n)
|===
// end::table[]
(((Linear)))
(((Runtime, Linear)))

If you compare the singly linked list vs. doubly linked list, you will notice that the main difference is inserting elements to and deleting elements from the end. For a singly linked list, it's *O(n)*, while a doubly-linked list is *O(1)*.

Comparing an array with a doubly-linked list, both have different use cases:

.Use arrays when:
- You want to access *random* elements by numeric key or index in constant time O(1).
- You need two-dimensional and multi-dimensional arrays.

.Use a doubly linked list when:
- You want to access elements in a *sequential* manner only like <<part02-linear-data-structures#stack>> or <<part02-linear-data-structures#queue>>.
- You want to insert elements at the start and end of the list. The linked list has O(1) while the array has O(n).
- You want to save some memory when dealing with possibly large data sets. Arrays pre-allocate a large chunk of contiguous memory on initialization. Lists are more “grow as you go.”

For the next two linear data structures <<part02-linear-data-structures#stack>> and <<part02-linear-data-structures#queue>>, we are going to use a doubly-linked list to implement them. We could use an array as well, but since inserting/deleting from the start performs better with linked-lists, we will use that.

==== Practice Questions
(((Interview Questions, Linked Lists)))

// tag::linkedlist-q-merge-lists[]
===== Merge Linked Lists into One

*LL-1*) _Merge two sorted lists into one (and keep them sorted)_

Examples:

----
mergeTwoLists(2->3->4, 1->2); // 1->2->2->3->4
mergeTwoLists(2->3->4,null); // 2->3->4
----

// _Seen in interviews at: Amazon, Adobe, Microsoft, Google_
// end::linkedlist-q-merge-lists[]

[source, javascript]
----
include::../../interview-questions/merge-lists.js[tag=description]
  // write you code here
}
----

_Solution: <<linkedlist-q-merge-lists>>_




// tag::linkedlist-q-linkedlist-same-data[]
===== Check if two strings lists are the same

*LL-2*) _Given two linked lists with strings, check if the data is equivalent._

Examples:

----
hasSameData(he->ll->o, hel->lo); // true
hasSameData(hello, hel->lo); // true
hasSameData(he->ll->o, h->i); // false
----

// _Seen in interviews at: Facebook_
// end::linkedlist-q-linkedlist-same-data[]

[source, javascript]
----
include::../../interview-questions/linkedlist-same-data.js[tag=description]
  // write you code here
}
----

_Solution: <<linkedlist-q-linkedlist-same-data>>_
